<!DOCTYPE html>
<html lang="zh-Hans">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="王思懿">





<title>games_Lec 07~09 - Shading 光照、着色、着色频率、图形管线、纹理映射 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 7.1.1"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">KikiGirls&#39;blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">KikiGirls&#39;blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">games_Lec 07~09 - Shading 光照、着色、着色频率、图形管线、纹理映射</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">王思懿</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">October 22, 2024&nbsp;&nbsp;0:23:28</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/games101/">games101</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="前期回顾"><a href="#前期回顾" class="headerlink" title="前期回顾"></a>前期回顾</h1><p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2022.47.44.png" alt="alt text"></p>
<p>在前面的课我们已经实现了</p>
<ul>
<li>MVP视角变换</li>
<li>将模型画到屏幕上</li>
<li>判断点是否在三角形内部，然后着色</li>
</ul>
<h1 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h1><p><strong>着色</strong>：将材料应用在物体上面，</p>
<h2 id="Blinn-Phong-Reflectance-Model-光照模型-着色模型"><a href="#Blinn-Phong-Reflectance-Model-光照模型-着色模型" class="headerlink" title="Blinn-Phong Reflectance Model 光照模型 着色模型"></a>Blinn-Phong Reflectance Model 光照模型 着色模型</h2><p><em>这个人发明的着色方法</em></p>
<h3 id="Diffuse-漫反射"><a href="#Diffuse-漫反射" class="headerlink" title="Diffuse (漫反射)"></a>Diffuse (漫反射)</h3><p><em>一束光照到点上往四面八方反射出来。</em></p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2023.02.12.png" alt="alt text"></p>
<p>所以无论我们从那个方向看见反射回来的光都是一样的。但是反射回来的光强和入射角度以及距离有关。</p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2023.05.42.png" alt="alt text"></p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2023.12.15.png" alt="alt text"></p>
<p>$$<br>L_{d}&#x3D;k_{d}\left(I &#x2F; r^{2}\right) \max (0, \mathbf{n} \cdot \mathbf{l})<br>$$</p>
<p>几个变量：$k_d, r, n, l$ （反射系数，入射光强，距离，法线于入射角度。）</p>
<h3 id="Specular-高光"><a href="#Specular-高光" class="headerlink" title="Specular(高光)"></a>Specular(高光)</h3><p><em>和漫反射不一样，高光只能在特定角度看见。</em></p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2023.17.04.png" alt="alt text"></p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2023.18.35.png" alt="alt text"> </p>
<p>公式和漫反射类似，但是我们需要用半程向量来求这个高光角度，因为半程向量比较好算。</p>
<p>为了控制高光大小我们加了幂系数，p一般100～200。</p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2023.21.36.png" alt="alt text"></p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2023.22.28.png" alt="alt text"></p>
<h3 id="Ambient-环境光"><a href="#Ambient-环境光" class="headerlink" title="Ambient 环境光"></a>Ambient 环境光</h3><ul>
<li>是假的</li>
<li>$L_{a}&#x3D;k_{a} I_{a}$</li>
<li>提升亮度，为了不让有完全黑的地方。</li>
<li>真的：全局光照（GI）十分复杂</li>
</ul>
<h3 id="tol"><a href="#tol" class="headerlink" title="tol"></a>tol</h3><p><em>每一点的光照都是这三种合起来</em></p>
<p>$$<br>\begin{aligned} L &amp;&#x3D;L_{a}+L_{d}+L_{s} \ &amp;&#x3D;k_{a} I_{a}+k_{d}\left(I &#x2F; r^{2}\right) \max (0, \mathbf{n} \cdot \mathbf{l})+k_{s}\left(I &#x2F; r^{2}\right) \max (0, \mathbf{n} \cdot \mathbf{h})^{p} \end{aligned}<br>$$</p>
<ul>
<li>h是半程向量</li>
</ul>
<p>Shading is Local：对某个点进行计算，局部，只看自己，不管其他物体的存在</p>
<p>光的能量密度的 平方反比定律</p>
<ul>
<li>点离光源的radiance</li>
</ul>
<p>点离观察点的距离无关</p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2023.26.31.png" alt="alt text"></p>
<h2 id="Shading-Frequencies-着色频率"><a href="#Shading-Frequencies-着色频率" class="headerlink" title="Shading Frequencies 着色频率"></a>Shading Frequencies 着色频率</h2><p><em>上面我们解决了每一个像素的光照，所以接下来要对全体进行取样</em></p>
<h3 id="flat-shading"><a href="#flat-shading" class="headerlink" title="flat shading:"></a>flat shading:</h3><ul>
<li>每个三角形的法线是一样的，shading一次获得颜色值</li>
</ul>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2023.30.42.png" alt="alt text"></p>
<h3 id="Gouraud-Shading"><a href="#Gouraud-Shading" class="headerlink" title="Gouraud Shading"></a>Gouraud Shading</h3><ul>
<li>每个顶点做一次Shading，中间对颜色值插值</li>
</ul>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2023.32.18.png" alt="alt text"></p>
<h3 id="Phong-Shading"><a href="#Phong-Shading" class="headerlink" title="Phong Shading"></a>Phong Shading</h3><ul>
<li>对法线值做插值，对每个点做Shading</li>
<li>Not the Blinn-Phong Reﬂectance Model</li>
</ul>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2023.34.05.png" alt="alt text"></p>
<ul>
<li><p>几何足够复杂的情况下，用简单的Shading方法也可以达到好的效果</p>
</li>
<li><p>好的效果一般需要大的计算量</p>
</li>
</ul>
<h3 id="顶点法线"><a href="#顶点法线" class="headerlink" title="顶点法线"></a>顶点法线</h3><p><em>对面求平均</em></p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2023.36.57.png" alt="alt text"></p>
<h3 id="每个像素的法线"><a href="#每个像素的法线" class="headerlink" title="每个像素的法线"></a>每个像素的法线</h3><p><em>顶点的插值</em></p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-22%2023.38.00.png" alt="alt text"></p>
<h2 id="图形管线-Real-time-Rendering-Pipeline"><a href="#图形管线-Real-time-Rendering-Pipeline" class="headerlink" title="图形管线 Real-time Rendering Pipeline"></a>图形管线 Real-time Rendering Pipeline</h2><p><em>渲染的流程</em></p>
<p><img src="/img/games101/lec07/image.png" alt="alt text"></p>
<ul>
<li>Vertex Processing <ul>
<li>Model, View, Projection transforms</li>
<li>Shading, Texture mapping</li>
<li>Output: Vertex Stream</li>
</ul>
</li>
<li>Triangle Processing<ul>
<li>Output: Triangle Stream</li>
</ul>
</li>
<li>Rasterization<ul>
<li>Sampling</li>
<li>Output: Fragment Stream</li>
</ul>
</li>
<li>Fragment Processing<ul>
<li>Z-Buffer Visibility Tests</li>
<li>Shading, Texture mapping</li>
<li>Output: Shaded Fragments</li>
</ul>
</li>
<li>Framebuffer Operations<ul>
<li>Output: image (pixels)</li>
</ul>
</li>
</ul>
<p><strong>Shader Programs</strong></p>
<ul>
<li>Program vertex and fragment processing stages</li>
<li>自己编程顶点和像素的着色流程</li>
<li>Describe operation on <strong>a single vertex (or fragment)</strong></li>
<li>每个元素都执行一次</li>
<li>vertex &#x2F; fragment shader</li>
<li>More:<ul>
<li>Geometry Shader</li>
<li>Compute Shader</li>
</ul>
</li>
</ul>
<h2 id="Texture-Mapping-纹理映射"><a href="#Texture-Mapping-纹理映射" class="headerlink" title="Texture Mapping 纹理映射"></a>Texture Mapping 纹理映射</h2><ul>
<li>三维物体表面都是二维的</li>
<li>纹理：图，有弹性，可以映射到表面</li>
<li>uv：[0,1]^2</li>
<li>三角形每个顶点对应一个uv坐标</li>
<li>一张纹理可以使用多次</li>
<li>纹理本身设计可以无缝衔接→tilable<ul>
<li>一种方法：Wang Tiling</li>
</ul>
</li>
</ul>
<h2 id="Barycentric-coordinates-重心坐标→插值"><a href="#Barycentric-coordinates-重心坐标→插值" class="headerlink" title="Barycentric coordinates 重心坐标→插值"></a>Barycentric coordinates 重心坐标→插值</h2><p>三角形三个顶点的坐标和内部某点坐标的关系：</p>
<p>$$<br>\begin{array}{r} (x, y)&#x3D;\alpha A+\beta B+\gamma C \ \alpha+\beta+\gamma&#x3D;1 \end{array}<br>$$<br>投影前后的重心坐标可能会变化，所以需要在对应时间计算对应的重心坐标来做插值，不能随意复用</p>
<p>像素在三角形内→计算对应uv→取纹理对应颜色值→设置</p>
<p>三角形点也是线性组合。</p>
<p><img src="/img/games101/lec07/image%20copy.png" alt="alt text"></p>
<p><em>问题1: Texture Magnification 纹理太小怎么办 → 插值</em></p>
<ul>
<li>纹理像素：texel</li>
<li>多个pixel映射到了同一个texel</li>
<li>解决：<ul>
<li>Nearest（取最近的点）</li>
<li>Bilinear<ul>
<li>Bilinear 插值 lerp</li>
<li>水平+竖直插值→双线性插值</li>
<li>最近的四个点插值</li>
</ul>
</li>
<li>Bicubic 双向三次插值<ul>
<li>周围16个点做三次插值</li>
<li>运算量更大，结果更好</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2015.57.35.png" alt="alt text"></p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2015.59.35.png" alt="alt text"></p>
<p><em>问题2: Texture Magnification 纹理太大怎么办</em></p>
<ul>
<li>一个pixel对应了多个texel → 采样频率不足导致 摩尔纹+锯齿（走样）</li>
</ul>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.00.53.png" alt="sf"></p>
<p><img src="/img/games101/lec07/image%20copy%202.png" alt="alt text"></p>
<p>有一个像素占了太多位置。、</p>
<ul>
<li>解决：<ul>
<li>Supersampling<ul>
<li>太浪费！</li>
<li>超采样。</li>
<li>Just need to get the average value within a range（取平均颜色）<ul>
<li>Point Query vs. <strong>(Avg.) Range Query</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.07.15.png" alt="alt text"></p>
<ul>
<li>Mipmap：Allowing (<strong>fast, approx., square</strong>) range queries</li>
<li>每一次长宽各减半 D&#x3D;0,1,2,…<ul>
<li>提前做好缩略图。</li>
<li>“Mip hierarchy”</li>
<li>overhead: 1&#x2F;3</li>
<li>增加不到1倍的大小。</li>
<li>怎么知道层数D？约为相邻pixel的映射uv之间的距离取2的对数</li>
<li>如果计算出来需要的D是整数，就很方便</li>
<li>如果计算出来需要的D不是整数→Trilinear Interpolation三线性插值<ul>
<li>分别在floor(D)和ceil(D)上做Bilinear Interpolation取颜色值之后再插值</li>
</ul>
</li>
<li>Limitation：Overblur<ul>
<li>不是方块查询</li>
<li>Solution：各向异性过滤</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.08.42.png" alt="alt text"> </p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.11.09.png" alt="alt text"></p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.13.56.png" alt="三线性插值"></p>
<p><em>三线性插值</em></p>
<ul>
<li>各向异性过滤Anisotropic Filtering<ul>
<li>Ripmaps and summed area tables<ul>
<li>Can look up axis-aligned rectangular zones</li>
<li>长&#x2F;宽&#x2F;长和宽 各减半</li>
</ul>
</li>
<li>EWA filtering 椭圆取样<ul>
<li>利用多次查询求平均值的方法来处理不规则区域</li>
</ul>
</li>
<li>overhead：3</li>
<li>多少x：压缩到多少x，显存足够的情况下开越高越好</li>
</ul>
</li>
</ul>
<p>像素覆盖的区域大小各不相同 </p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.19.05.png" alt="alt text"><br><em>采样对应的是不规则形状。</em></p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.19.58.png" alt="alt text"></p>
<h2 id="Application-of-Texture"><a href="#Application-of-Texture" class="headerlink" title="Application of Texture"></a>Application of Texture</h2><p>各种贴图</p>
<p>texture &#x3D; memory + range query (filtering)纹理&#x3D;内存+范围查询（过滤）</p>
<ul>
<li><p>General method to bring data to fragment calculations</p>
</li>
<li><p>Environment lighting - Environment Map</p>
<ul>
<li>环境光贴图</li>
<li>例子：Utah Teapot<ul>
<li>经典：Stanford Bunny，Cornell Box</li>
</ul>
</li>
<li>Spherical Environment Map<ul>
<li>球心：世界中心</li>
<li>一个问题：拉伸，想象地球仪展开</li>
<li>解决方法：Cube Map</li>
</ul>
</li>
<li>Cube Map：立方体表面，从球心到球面的投影向外<ul>
<li>扭曲更少，但是Need dir-&gt;face computation，计算量更大</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.25.56.png" alt="alt text"><br><em>Stanford Bunny</em></p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.26.50.png" alt="alt text"></p>
<p><em>Spherical Environment Map</em></p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.27.29.png" alt="alt text"></p>
<ul>
<li>Store microgeometry<ul>
<li><p>Textures can affect shading! → define height&#x2F;normal → Bump &#x2F; Normal Map</p>
<ul>
<li>两者类似，都可以以假乱真</li>
<li>改变表面的法线</li>
</ul>
</li>
<li><p>Bump Mapping 凹凸贴图</p>
<p>  Bump Mapping的Texture记录了高度移动</p>
<ul>
<li>不改变几何信息</li>
<li>逐像素扰动法线方向</li>
<li>高度 offset 相对变化，从而改变法线方向</li>
<li>计算法线方向：切线的垂直方向</li>
</ul>
</li>
<li><p>Displacement mapping 位移贴图</p>
<ul>
<li>输入相同（Texture与Bump Mapping可共用）</li>
<li>改变几何信息，对顶点做位移</li>
<li>相比上更逼真，要求模型足够细致，运算量更高</li>
<li>DirectX有Dynamic的插值法，对模型做插值，使得初始不用过于细致</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.31.10.png" alt="alt text"></p>
<p><em>计算方法</em></p>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.31.50.png" alt="alt text"></p>
<p><em>两种区别</em></p>
<ul>
<li>Procedural textures<ul>
<li>3D Procedural Noise + Solid Modeling<ul>
<li>定义空间中任意点的颜色</li>
<li>噪声+映射→</li>
<li>Perlin Noise</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.33.00.png" alt="alt text"></p>
<ul>
<li>Provide Precomputed Shading<ul>
<li>Ambient occlusion texture map<ul>
<li>计算好的环境光遮蔽贴图</li>
<li>空间换时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.33.21.png" alt="alt text"></p>
<ul>
<li>Solid modeling &amp; Volume rendering<ul>
<li>三维渲染<br><img src="/img/games101/lec07/%E6%88%AA%E5%B1%8F2024-10-30%2016.33.53.png" alt="alt text"></li>
</ul>
</li>
</ul>
<h2 id="阴影映射"><a href="#阴影映射" class="headerlink" title="阴影映射"></a>阴影映射</h2><p>在光栅化中，对全局光照传输和阴影的处理相当复杂。</p>
<ul>
<li>使用光栅化绘制阴影</li>
<li>图像空间算法<ul>
<li>不需要场景的几何信息</li>
<li>会出现锯齿现象</li>
<li>思路：不在阴影中的点必须既能被光源看到，也能被相机看到</li>
</ul>
</li>
</ul>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ul>
<li><strong>Pass 1: 从光源渲染</strong><ul>
<li>从光源渲染深度图像 → 阴影贴图</li>
</ul>
</li>
<li><strong>Pass 2A: 从眼睛渲染</strong><ul>
<li>从视角渲染标准图像（包含深度信息）</li>
</ul>
</li>
<li><strong>Pass 2B: 投影到光源</strong><ul>
<li>将视角下可见的点投影回光源<ul>
<li>可见的点 → 着色</li>
<li>被遮挡的点 → 阴影</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通常每个光源对每个静态场景都有一个阴影贴图。</p>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul>
<li>几乎所有的3D游戏</li>
</ul>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ul>
<li>锯齿、分辨率限制</li>
<li>数值精度问题<ul>
<li>涉及浮点深度值的等值比较，意味着会遇到缩放、偏差和容差问题</li>
</ul>
</li>
<li>仅支持点光源、只能生成硬阴影</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>王思懿</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span><strong>白鸟青山鸣，迷途何复归</strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/10/29/leetcode/1/">1.数组</a>
            
            
            <a class="next" rel="next" href="/2024/10/19/games101/games101_lec06/">games_lec06Antialiasing and Z-Buffering(反走样)</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 王思懿 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>