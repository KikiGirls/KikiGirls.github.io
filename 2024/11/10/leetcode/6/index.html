<!DOCTYPE html>
<html lang="zh-Hans">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="王思懿">





<title>6.栈与队列 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 7.1.1"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">KikiGirls&#39;blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">KikiGirls&#39;blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">6.栈与队列</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">王思懿</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 10, 2024&nbsp;&nbsp;23:30:28</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">代码随想录</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="栈与队列的理论基础"><a href="#栈与队列的理论基础" class="headerlink" title="栈与队列的理论基础"></a>栈与队列的理论基础</h1><h2 id="1-栈（Stack）"><a href="#1-栈（Stack）" class="headerlink" title="1. 栈（Stack）"></a>1. 栈（Stack）</h2><h3 id="1-1-栈的定义"><a href="#1-1-栈的定义" class="headerlink" title="1.1 栈的定义"></a>1.1 栈的定义</h3><ul>
<li><strong>栈（Stack）</strong> 是一种<strong>后进先出</strong>（LIFO, Last In First Out）数据结构。</li>
<li>数据只能在栈顶进行插入和删除操作。</li>
</ul>
<h3 id="1-2-栈的基本操作"><a href="#1-2-栈的基本操作" class="headerlink" title="1.2 栈的基本操作"></a>1.2 栈的基本操作</h3><ul>
<li><strong>push(x)</strong>: 将元素 <code>x</code> 压入栈顶。</li>
<li><strong>pop()</strong>: 移除并返回栈顶元素。</li>
<li><strong>top()</strong>: 返回栈顶元素但不删除。</li>
<li><strong>isEmpty()</strong>: 判断栈是否为空。</li>
</ul>
<h3 id="1-3-栈的应用场景"><a href="#1-3-栈的应用场景" class="headerlink" title="1.3 栈的应用场景"></a>1.3 栈的应用场景</h3><ul>
<li><strong>函数调用栈</strong>：用于存储程序执行的调用顺序，遵循后进先出规则。</li>
<li><strong>括号匹配</strong>：检查表达式中的括号是否配对。</li>
<li><strong>逆序处理</strong>：实现字符串反转等。</li>
</ul>
<h3 id="1-4-栈的实现方式"><a href="#1-4-栈的实现方式" class="headerlink" title="1.4 栈的实现方式"></a>1.4 栈的实现方式</h3><ul>
<li><strong>数组</strong>实现：基于固定大小数组的顺序栈，需提前定义栈的最大容量。</li>
<li><strong>链表</strong>实现：基于链表的链式栈，容量动态分配，不限栈大小。</li>
</ul>
<h2 id="2-队列（Queue）"><a href="#2-队列（Queue）" class="headerlink" title="2. 队列（Queue）"></a>2. 队列（Queue）</h2><h3 id="2-1-队列的定义"><a href="#2-1-队列的定义" class="headerlink" title="2.1 队列的定义"></a>2.1 队列的定义</h3><ul>
<li><strong>队列（Queue）</strong> 是一种<strong>先进先出</strong>（FIFO, First In First Out）数据结构。</li>
<li>数据在队尾插入，在队首删除。</li>
</ul>
<h3 id="2-2-队列的基本操作"><a href="#2-2-队列的基本操作" class="headerlink" title="2.2 队列的基本操作"></a>2.2 队列的基本操作</h3><ul>
<li><strong>enqueue(x)</strong>: 将元素 <code>x</code> 插入队尾。</li>
<li><strong>dequeue()</strong>: 移除并返回队首元素。</li>
<li><strong>front()</strong>: 返回队首元素但不删除。</li>
<li><strong>isEmpty()</strong>: 判断队列是否为空。</li>
</ul>
<h3 id="2-3-队列的应用场景"><a href="#2-3-队列的应用场景" class="headerlink" title="2.3 队列的应用场景"></a>2.3 队列的应用场景</h3><ul>
<li><strong>任务调度</strong>：按照顺序执行的任务列表。</li>
<li><strong>广度优先搜索（BFS）</strong>：使用队列记录节点访问顺序。</li>
<li><strong>缓存机制</strong>：按顺序管理访问过的资源或数据。</li>
</ul>
<h3 id="2-4-队列的实现方式"><a href="#2-4-队列的实现方式" class="headerlink" title="2.4 队列的实现方式"></a>2.4 队列的实现方式</h3><ul>
<li><strong>数组</strong>实现：固定大小的顺序队列，但容易发生“假溢出”。</li>
<li><strong>循环数组</strong>实现：在顺序队列的基础上加入循环特性，提高空间利用率。</li>
<li><strong>链表</strong>实现：链式队列，队列大小不受限。</li>
</ul>
<h2 id="3-栈与队列的扩展结构"><a href="#3-栈与队列的扩展结构" class="headerlink" title="3. 栈与队列的扩展结构"></a>3. 栈与队列的扩展结构</h2><h3 id="3-1-双端队列（Deque）"><a href="#3-1-双端队列（Deque）" class="headerlink" title="3.1 双端队列（Deque）"></a>3.1 双端队列（Deque）</h3><ul>
<li>双端队列允许在队首和队尾进行插入和删除操作。</li>
<li><strong>应用</strong>：滑动窗口问题、最短路径算法等。</li>
</ul>
<h3 id="3-2-优先队列（Priority-Queue）"><a href="#3-2-优先队列（Priority-Queue）" class="headerlink" title="3.2 优先队列（Priority Queue）"></a>3.2 优先队列（Priority Queue）</h3><ul>
<li>元素按照优先级进行排序，高优先级元素先出队。</li>
<li><strong>应用</strong>：最短路径算法、事件调度系统等。</li>
</ul>
<h2 id="4-栈与队列的比较"><a href="#4-栈与队列的比较" class="headerlink" title="4. 栈与队列的比较"></a>4. 栈与队列的比较</h2><table>
<thead>
<tr>
<th>特性</th>
<th>栈（Stack）</th>
<th>队列（Queue）</th>
</tr>
</thead>
<tbody><tr>
<td>存取顺序</td>
<td>后进先出（LIFO）</td>
<td>先进先出（FIFO）</td>
</tr>
<tr>
<td>操作限制</td>
<td>仅在栈顶操作</td>
<td>队首删除，队尾插入</td>
</tr>
<tr>
<td>典型应用场景</td>
<td>函数调用、括号匹配</td>
<td>任务调度、BFS</td>
</tr>
<tr>
<td>实现方式</td>
<td>数组、链表</td>
<td>数组、循环数组、链表</td>
</tr>
</tbody></table>
<h2 id="5-栈与队列的常见算法题目"><a href="#5-栈与队列的常见算法题目" class="headerlink" title="5. 栈与队列的常见算法题目"></a>5. 栈与队列的常见算法题目</h2><ul>
<li>栈题目：<ul>
<li><strong>有效的括号</strong>（判断括号是否成对匹配）</li>
<li><strong>最小栈</strong>（支持常数时间内获取最小值的栈）</li>
</ul>
</li>
<li>队列题目：<ul>
<li><strong>滑动窗口最大值</strong>（在滑动窗口中找到最大值）</li>
<li><strong>用栈实现队列</strong> &#x2F; <strong>用队列实现栈</strong></li>
</ul>
</li>
</ul>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ul>
<li>栈与队列是基础的数据结构，具有明确的操作限制，用于管理数据的存取顺序。</li>
<li>它们在程序调用、资源管理、广度优先搜索等方面有广泛应用。</li>
<li>掌握栈与队列的操作和应用场景，是学习数据结构与算法的基础。</li>
</ul>
<h1 id="栈与队列相关题目"><a href="#栈与队列相关题目" class="headerlink" title="栈与队列相关题目"></a>栈与队列相关题目</h1><ul>
<li><input disabled="" type="checkbox"> <ol>
<li>栈与队列理论基础</li>
</ol>
</li>
<li><input disabled="" type="checkbox"> <ol start="2">
<li>用栈实现队列</li>
</ol>
</li>
<li><input disabled="" type="checkbox"> <ol start="3">
<li>用队列实现栈</li>
</ol>
</li>
<li><input disabled="" type="checkbox"> <ol start="4">
<li>有效的括号</li>
</ol>
</li>
<li><input disabled="" type="checkbox"> <ol start="5">
<li>删除字符串中的所有相邻重复项</li>
</ol>
</li>
<li><input disabled="" type="checkbox"> <ol start="6">
<li>逆波兰表达式求值</li>
</ol>
</li>
<li><input disabled="" type="checkbox"> <ol start="7">
<li>滑动窗口最大值</li>
</ol>
</li>
<li><input disabled="" type="checkbox"> <ol start="8">
<li>前K个高频元素</li>
</ol>
</li>
<li><input disabled="" type="checkbox"> <ol start="9">
<li>栈与队列总结</li>
</ol>
</li>
</ul>
<h2 id="栈与队列理论基础"><a href="#栈与队列理论基础" class="headerlink" title="栈与队列理论基础"></a>栈与队列理论基础</h2><p>队列是先进先出，栈是先进后出。<br>那么我这里再列出四个关于栈的问题</p>
<p>C++中stack 是容器么？<br>我们使用的stack是属于哪个版本的STL？<br>我们使用的STL中stack是如何实现的？<br>stack 提供迭代器来遍历stack空间么？</p>
<p>栈和队列是STL（C++标准库）里面的两个数据结构。</p>
<p>C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。</p>
<p>那么来介绍一下，三个最为普遍的STL版本：</p>
<p>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</p>
<p>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</p>
<p>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</p>
<p>接下来介绍的栈和队列也是SGI STL里面的数据结构， 知道了使用版本，才知道对应的底层实现。</p>
<p>栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。</p>
<p>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</p>
<p>所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p>
<p>那么问题来了，STL 中栈是用什么容器实现的？</p>
<p>从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。</p>
<p>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</p>
<p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p>
<p>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</p>
<p>我们也可以指定vector为栈的底层实现，初始化语句如下：</p>
<p>std::stack&lt;int, std::vector<int> &gt; third;  &#x2F;&#x2F; 使用vector为底层容器的栈<br>刚刚讲过栈的特性，对应的队列的情况是一样的。</p>
<p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, SGI STL中队列一样是以deque为缺省情况下的底部结构。</p>
<p>也可以指定list 为起底层实现，初始化queue的语句如下：</p>
<p>std::queue&lt;int, std::list<int>&gt; third; &#x2F;&#x2F; 定义以list为底层容器的队列<br>所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。</p>
<h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p>在实现 MyQueue 类时，用两个栈来模拟队列的行为通常会涉及一个主栈（用于存放输入）和一个辅助栈（用于输出）。一个常见的命名约定是使用 inputStack 和 outputStack，因为这些名字可以很好地表达它们的用途：</p>
<pre><code>•	inputStack：作为主栈，用于存放新插入的元素。
•	outputStack：作为辅助栈，用于反转 inputStack 中的元素，从而实现队列的先进先出（FIFO）行为。
</code></pre>
<p>可以看出peek()的实现，直接复用了pop()， 要不然，对stOut判空的逻辑又要重写一遍。</p>
<p>再多说一些代码开发上的习惯问题，在工业级别代码开发中，最忌讳的就是 实现一个类似的函数，直接把代码粘过来改一改就完事了。</p>
<p>这样的项目代码会越来越乱，一定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题！（踩过坑的人自然懂）</p>
<h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果s的长度为奇数，一定不符合要求</span></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span></span><br><span class="line">            <span class="comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>(); <span class="comment">// st.top() 与 s[i]相等，栈弹出元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> x : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">empty</span>() || res.<span class="built_in">back</span>() != x) res.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">else</span> res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p>相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是Segmentation fault（当然不是所有的Segmentation fault 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。</p>
<h2 id="波兰表达式"><a href="#波兰表达式" class="headerlink" title="波兰表达式"></a>波兰表达式</h2><p>逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。</p>
<p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</p>
<p>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</p>
<p>逆波兰表达式主要有以下两个优点：</p>
<p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</p>
<p>适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。</p>
<p>所以栈与递归之间在某种程度上是可以转换的！ 这一点我们在后续讲解二叉树的时候，会更详细的讲解到。</p>
<p>那么来看一下本题，其实逆波兰表达式相当于是二叉树中的后序遍历。 大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。</p>
<p>但我们没有必要从二叉树的角度去解决这个问题，只要知道逆波兰表达式是用后序遍历的方式把二叉树序列化了，就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; sta;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="string">&quot;-&quot;</span> || n == <span class="string">&quot;+&quot;</span> || n == <span class="string">&quot;*&quot;</span> || n == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> x1 = sta.<span class="built_in">top</span>();sta.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> x2 = sta.<span class="built_in">top</span>(); sta.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="string">&quot;-&quot;</span>) sta.<span class="built_in">push</span>(x2 - x1);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="string">&quot;+&quot;</span>) sta.<span class="built_in">push</span>(x1 + x2);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="string">&quot;*&quot;</span>)  sta .<span class="built_in">push</span>(x1 * x2);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="string">&quot;/&quot;</span>) sta.<span class="built_in">push</span>(x2 / x1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sta.<span class="built_in">push</span>(<span class="built_in">stoll</span>(n));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sta.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>stoll 是 C++ 标准库中的一个函数，用于将 string 类型转换为 long long 类型（即 64 位整数）。它是 std::stol 系列函数的一部分，其他类似的函数包括 stoi（转换为 int）、stoul（转换为 unsigned long）、stof（转换为 float）、stod（转换为 double）等。</p>
<pre><code>•	&quot;（双引号）通常用于包围字符串，比如 &quot;Hello, World!&quot;，表示一整个字符串。
•	’（右单引号或撇号）在编程语言中一般不用于包围字符串，但可能用于字符表示或标识所有权、缩写等（例如 can&#39;t）
</code></pre>
<h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>有的同学可能会想用一个大顶堆（优先级队列）来存放这个窗口里的k个数字，这样就可以知道最大的最大值是多少了， 但是问题是这个窗口是移动的，而大顶堆每次只能弹出最大值，我们无法移除其他数值，这样就造成大顶堆维护的不是滑动窗口里面的数值了。所以不能用大顶堆。</p>
<p>此时我们需要一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么</p>
<p>每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.front()就返回我们要的最大值。</p>
<p>其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</p>
<p>那么这个维护元素单调递减的队列就叫做单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来实现一个单调队列</p>
<p>大家貌似对单调队列 都有一些疑惑，首先要明确的是，题解中单调队列里的pop和push接口，仅适用于本题哈。单调队列不是一成不变的，而是不同场景不同写法，总之要保证队列里单调递减或递增的原则，所以叫做单调队列。 不要以为本题中的单调队列实现就是固定的写法哈。</p>
<p>大家貌似对deque也有一些疑惑，C++中deque是stack和queue默认的底层实现容器（这个我们之前已经讲过啦），deque是可以两边扩展的，而且deque里元素并不是严格的连续分布的。</p>
<p>这个感觉比k’m’p好理解一点。个人感觉就是忽略掉那些不单调的，这样就可以永远让最大的在前面、</p>
<p>双端队列存储索引：在代码中使用 deque 存储 nums 元素的索引，而不是元素本身，以便更好地处理窗口滑动的范围和过期元素的删除。<br>    2.	边界检查：确保在每次滑动窗口后，移除已经滑出窗口范围的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[que.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (que.<span class="built_in">front</span>() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt; k - <span class="number">2</span>) result.<span class="built_in">push_back</span>(nums[que.<span class="built_in">front</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己做双端队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="type">int</span> f = <span class="number">0</span> , b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> q[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (f != b &amp;&amp; nums[q[b<span class="number">-1</span>]] &lt; nums[i]) b--;</span><br><span class="line">        q[b++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="built_in">push_back</span>(nums[q[f]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (f != b &amp;&amp; nums[q[b<span class="number">-1</span>]] &lt; nums[i]) b--;</span><br><span class="line">        q[b++] = i;</span><br><span class="line">        <span class="keyword">if</span> (q[f] &lt; i - k + <span class="number">1</span>) f++;</span><br><span class="line">        result.<span class="built_in">push_back</span>(nums[q[f]]);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="前k个高频元素"><a href="#前k个高频元素" class="headerlink" title="前k个高频元素"></a>前k个高频元素</h2><p>std::priority_queue&lt; T, Container, Compare &gt;</p>
<pre><code>•	T：队列中存储的元素类型。
•	Container：用于存储数据的底层容器类型。默认为 std::vector&lt;T&gt;。
•	Compare：比较元素的方式，默认是 std::less&lt;T&gt;，实现最大堆（最大值优先）。
</code></pre>
<p>在 ComparePerson 中，如果我们希望年龄小的优先，将比较器函数实现为 return p1.age &gt; p2.age; 是正确的。这是因为 priority_queue 默认情况下使用最大堆结构：比较器返回 true 表示优先队列认为 p1 的优先级低于 p2，因此 p1 会排在 p2 之后。</p>
<p>解释</p>
<pre><code>•	在这种比较器实现中，p1.age &gt; p2.age 返回 true，表示 p1 比 p2 的优先级低。
•	当 priority_queue 使用此比较器时，它会将年龄较小的元素排在队列顶部，即构成一个“最小堆”。
</code></pre>
<p>std::priority_queue&lt;int, std::vector<int>, std::greater<int>&gt; minHeap;<br>    •	push(value)：插入元素 value。<br>    •	pop()：移除优先级最高的元素。<br>    •	top()：返回优先级最高的元素（但不移除）。<br>    •	empty()：检查队列是否为空。<br>    •	size()：返回队列中的元素个数</p>
<pre><code>在 C++ 中，operator 关键字允许我们重载运算符，为自定义数据类型定义特定的运算行为。例如，你可以为自己的类定义 +、-、== 等运算符，使其能够像内置类型一样使用这些运算符。
</code></pre>
<ol>
<li>运算符重载概述</li>
</ol>
<p>运算符重载使我们能够为特定的操作符定义类的行为。它是一种让用户自定义类型支持常用运算的方式，从而提高代码的可读性和简洁性。<br>class Complex {<br>public:<br>    double real;<br>    double imag;</p>
<pre><code>Complex(double r, double i) : real(r), imag(i) &#123;&#125;

// 重载加法运算符
Complex operator+(const Complex&amp; other) const &#123;
    return Complex(real + other.real, imag + other.imag);
&#125;
</code></pre>
<p>};</p>
<pre><code>1.	struct ComparePerson:
•	定义一个名为 ComparePerson 的结构体。在 C++ 中，结构体（struct）和类（class）本质相同，只不过结构体的默认成员访问权限是 public，而类的默认权限是 private。
2.	bool operator()(const Person&amp; p1, const Person&amp; p2):
•	这里的 operator() 是一个特殊的函数重载，允许我们把 ComparePerson 对象当作函数来调用。这种语法称为“函数调用运算符重载”。
•	bool 是返回类型，这里返回 true 或 false，表示 p1 是否“优先于” p2。
•	(const Person&amp; p1, const Person&amp; p2) 是参数列表。const Person&amp; 表示参数是对 Person 对象的常量引用，不会修改原对象，并且通过引用避免了拷贝，提高了效率。
3.	return p1.age &gt; p2.age;:
•	这是比较逻辑的实现。
•	如果 p1.age &gt; p2.age 为 true，则 operator() 返回 true，意味着 p1 的优先级低于 p2，也就是说队列或容器会让 p2 排在 p1 之前。
•	按照这个规则，年龄越小的对象会有更高的优先级。
greater&lt;pair&lt;int, int&gt;&gt; 会根据 pair 的顺序比较规则进行降序排列，按键值对的第一个元素进行优先排序，第二个元素次之。
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">                unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;freqMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            freqMap[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;minHeap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [num,freq]:freqMap)&#123;</span><br><span class="line">            minHeap.<span class="built_in">push</span>(&#123;freq,num&#125;);</span><br><span class="line">            <span class="keyword">if</span>(minHeap.<span class="built_in">size</span>()&gt;k) &#123;</span><br><span class="line">                minHeap.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!minHeap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(minHeap.<span class="built_in">top</span>().second);</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            map[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; , Compare&gt;  pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> pair : map) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(pair);</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; k) pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i<span class="number">-1</span>] = pq.<span class="built_in">top</span>().first;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结篇"><a href="#总结篇" class="headerlink" title="总结篇"></a>总结篇</h2><p>首先我们在栈与队列：来看看栈和队列不为人知的一面 (opens new window)中讲解了栈和队列的理论基础。</p>
<p>里面提到了灵魂四问：</p>
<p>C++中stack，queue 是容器么？<br>我们使用的stack，queue是属于那个版本的STL？<br>我们使用的STL中stack，queue是如何实现的？<br>stack，queue 提供迭代器来遍历空间么？<br>相信不仅仅是C++中有这些问题，那么大家使用其他编程语言，也可以考虑一下这四个问题，栈和队列是如何实现的。</p>
<p>栈与队列是我们熟悉的不能再熟悉的数据结构，但它们的底层实现，很多同学都比较模糊，这其实就是基础所在。</p>
<p>可以出一道面试题：栈里面的元素在内存中是连续分布的么？</p>
<p>这个问题有两个陷阱：</p>
<p>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。<br>陷阱2：缺省情况下，默认底层容器是deque，那么deque在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。</p>
<p>栈经典题目<br>#栈在系统中的应用<br>如果还记得编译原理的话，编译器在词法分析的过程中处理括号、花括号等这个符号的逻辑，就是使用了栈这种数据结构。</p>
<p>再举个例子，linux系统中，cd这个进入目录的命令我们应该再熟悉不过了。</p>
<p>cd a&#x2F;b&#x2F;c&#x2F;..&#x2F;..&#x2F;<br>这个命令最后进入a目录，系统是如何知道进入了a目录呢 ，这就是栈的应用。这在leetcode上也是一道题目，编号：71. 简化路径，大家有空可以做一下。</p>
<p>递归的实现是栈：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p>所以栈在计算机领域中应用是非常广泛的</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>王思懿</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span><strong>白鸟青山鸣，迷途何复归</strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/11/10/leetcode/5/">5.字符串</a>
            
            
            <a class="next" rel="next" href="/2024/11/08/leetcode/4/">4.字符串</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 王思懿 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>