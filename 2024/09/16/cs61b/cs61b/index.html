<!DOCTYPE html>
<html lang="zh-Hans">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="王思懿">





<title>cs61b | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.1.1"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">KikiGirls&#39;blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">KikiGirls&#39;blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">cs61b</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">王思懿</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 16, 2024&nbsp;&nbsp;0:20:28</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Cs61b/">Cs61b</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>cs61a不能进了，所以开始学61b。</p>
<p>这是一个关于数据结构的课，用java。</p>
<p>用<a target="_blank" rel="noopener" href="https://www.gradescope.com作为自动评分机,版本21sp,对于环境配置部分,cs61b使用gradescope作为自动评分机.激活码mb7zpy,学校记得选uc/">https://www.gradescope.com作为自动评分机，版本21sp，对于环境配置部分，CS61B使用GradeScope作为自动评分机。激活码MB7ZPY，学校记得选UC</a> Berkeley</p>
<h1 id="hw0-java速成"><a href="#hw0-java速成" class="headerlink" title="hw0 java速成"></a>hw0 java速成</h1><p>java变量只能是整数</p>
<p>Java 中的每个语句后面都必须有一个分号。分号非常重要，因为它告诉 Java 一个语句在哪里结束，另一个语句在哪里开始。</p>
<p>条件判断的形式 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (boolValue) &#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">pass</span> <span class="operator">=</span> score =&gt; <span class="number">75</span>;</span><br><span class="line"><span class="keyword">if</span> (pass) &#123;</span><br><span class="line">    output(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>double 存储实数的近似值，并String存储字符串。</p>
<p>java中的数组形式 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">3</span>]</span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">System.out.println(numbers[<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者其他形式 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>for 循环的格式 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &gt; j; i += <span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>break或continue关键字很有用。该continue语句跳过循环当前迭代的其余部分，有效地直接跳转到增量条件。</p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>安装java<br>安装idea</p>
<h1 id="proj0"><a href="#proj0" class="headerlink" title="proj0"></a>proj0</h1><p>该项目的目的是让您有机会熟悉 Java 和课程中使用的各种工具.</p>
<p>风格指南<a target="_blank" rel="noopener" href="https://sp21.datastructur.es/materials/guides/style-guide.html">https://sp21.datastructur.es/materials/guides/style-guide.html</a></p>
<h1 id="java-简介"><a href="#java-简介" class="headerlink" title="java 简介"></a>java 简介</h1><h2 id="1-1要点"><a href="#1-1要点" class="headerlink" title="1.1要点"></a>1.1要点</h2><p>我们的变量 x 必须在使用之前声明，并且必须赋予其类型！<br>我们的循环定义包含在花括号内，而测试的布尔表达式包含在括号内。<br>我们的打印语句只是System.out.print而不是System.out.println。这意味着我们不应该包含换行符（返回）。</p>
<p>Java 最重要的特性之一是所有变量和表达式都有一个所谓的static type。Java 变量可以包含该类型的值，并且只能包含该类型的值。此外，变量的类型永远不会改变。</p>
<p><strong>总结,java是静态语言，变量的类型不能改变。</strong></p>
<p>由于所有 Java 代码都是类的一部分，因此我们必须定义函数，使它们属于某个类。属于类的函数通常称为“方法”。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 由于所有 Java 代码都是类的一部分，因此我们必须定义函数，使它们属于某个类。属于类的函数通常称为“方法”。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LargerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">larger</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(larger(<span class="number">8</span>, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在本课程中，我们将努力保持代码的可读性。良好编码风格的一些最重要特征包括：</p>
<p>一致的风格（间距、变量命名、括号样式等）<br>大小（行不太宽，源文件不太长）<br>描述性命名（变量、函数、类），例如变量或函数的名称为year或getUserName而不是x或f。<br>避免重复代码：除了少数变化外，几乎不应该有两个几乎相同的重要代码块。<br>在适当的位置添加注释。Java 中的行注释使用&#x2F;&#x2F;分隔符。块注释（又称多行注释）使用 &#x2F;<em>和</em>&#x2F;。</p>
<h2 id="1-2定义和使用类"><a href="#1-2定义和使用类" class="headerlink" title="1.2定义和使用类"></a>1.2定义和使用类</h2><p>hello world </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个可以看出java文件的格式</p>
<p>Java 程序文件均由一个个类构成，体现其面向对象编程的特点<br>类名与文件名相同<br>main 函数为类的主函数，其中String args[]表示 main 函数的参数(记住就行)<br>System.out.println()是 Java 的输出函数，类比 C++中的cout和printf</p>
<p>函数</p>
<p>java所有对象都属于类，所以我们在定义函数的时候必须在某个类下面定义函数。这被称为方法<br>public代表这个函数的公共方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogLauncher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">20</span>);</span><br><span class="line">        d.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里，实例化是参数化的</p>
<p>new 是用来创建实例化的对象</p>
<p>例如数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/* Create an array of two dogs. */</span></span><br><span class="line">        Dog[] dogs = <span class="keyword">new</span> <span class="title class_">Dog</span>[<span class="number">2</span>];</span><br><span class="line">        dogs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">8</span>);</span><br><span class="line">        dogs[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Yipping will result, since dogs[0] has weight 8. */</span></span><br><span class="line">        dogs[<span class="number">0</span>].makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java 允许我们定义两种类型的方法：<br>类方法，又称静态方法。实例方法，又称非静态方法。实例方法是只能由类的特定实例执行的操作。静态方法是类本身执行的操作</p>
<p>同理，使用static关键字定义的变量即为静态变量，可由类名直接调用</p>
<p>类Math提供了一种sqrt方法。因为它是静态的，所以我们可以按如下方式调用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x = Math.sqrt(<span class="number">100</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果sqrt是实例方法，我们就会使用下面尴尬的语法。幸运的sqrt是，这是一个静态方法，所以我们不必在实际程序中这样做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Math</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Math</span>();</span><br><span class="line">x = m.sqrt(<span class="number">100</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有时，让一个类同时具有实例方法和静态方法会很有意义。例如，假设想要比较两只狗。一种方法是添加一个用于比较狗的静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog d1, Dog d2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (d1.weightInPounds &gt; d2.weightInPounds) &#123;</span><br><span class="line">        <span class="keyword">return</span> d1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如，可以通过以下方式调用此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">15</span>);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">100</span>);</span><br><span class="line">Dog.maxDog(d, d2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>请注意，我们使用类名进行调用，因为此方法是静态方法。</p>
<p>我们也可以将其实现maxDog为非静态方法，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog d2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.weightInPounds &gt; d2.weightInPounds) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面我们使用关键字this来引用当前对象。例如，可以使用以下命令调用此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">15</span>);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">100</span>);</span><br><span class="line">d.maxDog(d2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>public：到目前为止，我们所有的方法都以此关键字开头。<br>static：它是一种静态方法，不与任何特定实例相关联。<br>void：它没有返回类型。<br>main：这是方法的名称。<br>String[] args：这是传递给main方法的参数。</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2,1"></a>2,1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">Walrus b;</span><br><span class="line">b = a;</span><br><span class="line">b.weight = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">y = x;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两个不一样，第一个是把ab都绑定在同一个对象了，后面一不同的数字是不同的对象。所以换对象了</p>
<p>位</p>
<p>一个有趣的观察是，72 和 H 都存储为 01001000。这就引发了一个问题：一段 Java 代码如何知道如何解释 01001000？</p>
<p>答案是通过类型！例如，考虑下面的代码：</p>
<p>char c &#x3D; ‘H’;<br>int x &#x3D; c;</p>
<p>如果我们运行此代码，我们会得到：</p>
<p>H<br>72<br>在这种情况下，x 和 c 变量都包含相同的位（嗯，几乎……），但是 Java 解释器在打印时对它们的处理方式不同。</p>
<p>Java 中有 8 种基本类型：byte、short、int、long、float、double、boolean 和 char。每种类型都有不同的属性，我们将在整个课程中讨论这些属性，但 short 和 float 除外，因为您可能永远不会使用这两个属性。</p>
<p>int x; 创建了一个盒子<br>x &#x3D; 2; 将2的位填进这个盒子里面</p>
<p>引用类型<br>上面我们说了有 8 种基本类型：byte、short、int、long、float、double、boolean、char。其他所有类型（包括数组）都不是基本类型，而是reference type。</p>
<p>java创建对象只会绑定64位的地址，然后地址再储存信息</p>
<h2 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h2><p>这里的 SLList 即为新的列表数据结构，同样的，可以添加得到一系列实用的方法，如addfirst,addlast,getfirst,getlast,但是这时得到的数据结构仍然有不方便以及危险的地方：</p>
<p>first 结点依然裸奔!<br>空列表无法舒适地 addlast<br>为此，我们继续优化，首先将结点类型改为 private，其次设置哨兵结点(sentinel)，即添加一个始终位于最前端的结点，</p>
<p>方法嵌套：在 Java 中，一个方法不能在另一个方法内部定义。你在 tilt 方法中嵌套定义了 Rowtilt 方法，这在 Java 中是不允许的。你需要将 Rowtilt 方法移到 tilt 方法外部，作为类的另一个独立方法。</p>
<p>在 Java 中，不能直接像某些动态类型语言（如 Python 或 JavaScript）那样在运行时给对象添加新的属性。Java 是一种静态类型语言，所有属性（成员变量）必须在类的定义中声明，不能在方法中动态添加新属性。</p>
<p>在 Java 中，方法之间无法直接访问彼此的局部变量，因为局部变量的作用域是局限于方法内部的。局部变量只能在声明它们的方法内使用，方法外部是无法直接访问或修改的。</p>
<p>在 Java 中，if 语句可以结合 逻辑运算符 来进行条件判断。常见的逻辑运算符包括：</p>
<pre><code>1.	或运算符（||）：表示 “或者”。如果任一条件为 true，整个表达式就为 true。
2.	与运算符（&amp;&amp;）：表示 “并且”。只有当所有条件都为 true 时，整个表达式才为 true。
3.	非运算符（!）：表示 “取反”。将 true 变为 false，将 false 变为 true。
</code></pre>
<h2 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h2><p>在 SLList 中，我们优化了裸数据结构带来的不便，同时添加了哨兵结点来维持不变性，但是，这样的 Lists 仍然具有一些可以优化的地方：</p>
<p>addLast时，总会遍历整个链表，如果我的列表长达一百万项，这将浪费时间<br>单向遍历，不利于快速访问元素&#x2F;删除元素，尤其是靠后的元素，每次访问都需要经历不必要的遍历<br>由此，我们引出双向链表——Double Linked List，即DLList</p>
<p>DLList</p>
<p>添加前向指针(这个说法不严谨但是我先这么写)，使得列表变成可以双向访问的类型：</p>
<p>public class IntNode {<br>    public IntNode prev;<br>    public int item;<br>    public IntNode next;<br>}<br>JAVA<br>同时为末端结点同样设置一个哨兵结点，由此得到的数据结构会类似下面的拓扑图：<br>也可以首尾共用一个哨兵结点，实现环形结构：</p>
<p>最后，加入“模板”(在 C++里是模板)，使得我们的列表“通用化”——</p>
<p>一个可以容纳任何类型的通用 DLList 看起来如下：</p>
<p>public class DLList<BleepBlorp> {<br>    private IntNode sentinel;<br>    private int size;</p>
<pre><code>public class IntNode &#123;
    public IntNode prev;
    public BleepBlorp item;
    public IntNode next;
    ...
&#125;
...
</code></pre>
<p>}<br>JAVA<br>现在我们已经定义了一个 DLList 类的通用版本，我们还必须使用特殊的语法来实例化这个类。为此，在声明时，我们将所需的类型放在尖括号内，并在实例化时使用空的尖括号。例如：</p>
<p>1<br>2<br>DLList<String> d2 &#x3D; new DLList&lt;&gt;(“hello”);<br>d2.addLast(“world”);<br>JAVA<br>由于泛型仅适用于引用类型，我们无法将原始类型如 int 或 double 放入尖括号中，例如 <int> 。相反，我们使用原始类型的引用版本，在 int 情况下是 Integer ，例如。</p>
<p>1<br>2<br>DLList<Integer> d1 &#x3D; new DLList&lt;&gt;(5);<br>d1.insertFront(10);<br>JAVA<br>有关使用通用类型的更多细微差别，我们将把它们推迟到本书的后面章节。现在，请使用以下经验法则：</p>
<p>在实现数据结构的.java 文件中，在类名之后的文件顶部只需指定一次泛型类型名称。<br>在其他 .java 文件中，使用您的数据结构时，在声明时指定特定的期望类型，并在实例化时使用空的尖括号运算符。<br>如果您需要实例化一个泛型到原始类型，请使用它们的原始等效项 Integer ， Double ， Character ， Boolean ， Long ， Short ， Byte 或 Float 。<br>细节：在实例化时，您也可以在尖括号内声明类型，尽管这并非必需，只要您也在同一行上声明变量。换句话说，下面的代码行是完全有效的，即使右侧的 Integer 是多余的。</p>
<p>1<br>DLList<Integer> d1 &#x3D; new DLList<Integer>(5);</p>
<h2 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h2><p>数组创建有三种有效符号。</p>
<p>x &#x3D; new int[3];<br>y &#x3D; new int[]{1, 2, 3, 4, 5};<br>int[] z &#x3D; {9, 10, 11, 12, 13};</p>
<p>以下代码展示了我们将用于处理数组的所有关键语法。尝试<br>int[] z &#x3D; null;<br>int[] x, y;</p>
<p>x &#x3D; new int[]{1, 2, 3, 4, 5};<br>y &#x3D; x;<br>x &#x3D; new int[]{-1, 2, 5, 4, 99};<br>y &#x3D; new int[3];<br>z &#x3D; new int[0];<br>int xL &#x3D; x.length;</p>
<p>String[] s &#x3D; new String[6];<br>s[4] &#x3D; “ketchup”;<br>s[x[3] - x[1]] &#x3D; “muffins”;</p>
<p>int[] b &#x3D; {9, 10, 11};<br>System.arraycopy(b, 0, x, 3, 2);<br>最后一行演示了将信息从一个数组复制到另一个数组的一种方法。System.arraycopy需要五个参数：</p>
<p>用作源的数组<br>从源数组中哪里开始<br>用作目标的数组<br>目标数组的起始位置<br>要复制多少个项目</p>
<p>在 Java 中，所谓的 2D 数组实际上只是一个数组的数组。它们遵循我们已经学过的对象规则，但让我们回顾一下这些规则，以确保我们理解它们的工作原理。</p>
<p>数组的数组的语法可能有点令人困惑。考虑代码int[][] bamboozle &#x3D; new int[4][]。这将创建一个名为的整数数组bamboozle。具体来说，这将创建四个内存框，每个内存框都可以指向一个整数数组（长度未指定）。</p>
<p>数组和类都可用于组织一堆记忆盒。在这两种情况下，记忆盒的数量都是固定的，即数组的长度不能改变，就像类字段不能添加或删除一样。</p>
<p>数组和类中的记忆盒之间的主要区别：</p>
<p>数组框使用符号进行编号和访问[]，类框使用点符号进行命名和访问。<br>数组框必须全部为同一类型。类框可以为不同类型。<br>这些差异的一个特别显著的影响是，[]符号允许我们在运行时指定我们想要的索引。例如，考虑下面的代码：</p>
<p>int indexOfInterest &#x3D; askUserForInteger();<br>int[] x &#x3D; {100, 101, 102, 103};<br>int k &#x3D; x[indexOfInterest];<br>System.out.println(k);<br>如果我们运行此代码，我们可能会得到类似这样的结果：</p>
<p>$ javac arrayDemo<br>$ java arrayDemo<br>What index do you want? 2<br>102</p>
<p>与其他语言中的数组相比，Java 数组：</p>
<p>没有用于“切片”的特殊语法（例如在 Python 中）。<br>无法缩小或扩大（例如在 Ruby 中）。<br>没有成员方法（例如在 Javascript 中）。<br>必须仅包含相同类型的值（与 Python 不同）。</p>
<h2 id="2-5-Alist"><a href="#2-5-Alist" class="headerlink" title="2.5 Alist"></a>2.5 Alist</h2><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h2><p>implements List61B<Item>本质上是一个承诺。AList 表示“我保证我将拥有并定义 List61B 接口中指定的所有属性和行为”</p>
<p>在子类中实现所需函数时，@Override在方法签名的顶部包含标记很有用</p>
<p>值得注意的是，即使您不包含此标记，您仍会覆盖该方法。因此从技术上讲，您不必包含它。但是，包含该标记可以作为程序员的保障，因为它会提醒编译器您打算覆盖此方法。您可能会问这有什么用？嗯，这有点像有校对员！如果在此过程中出现问题，编译器会告诉您。</p>
<p>假设您想覆盖该addLast方法。如果您输入错误并意外地写了 怎么办addLsat？如果您不包含 @Override 标记，那么您可能无法发现错误，这可能会使调试过程变得更加困难和痛苦。而如果您包含 @Override，编译器将停止并提示您在程序运行之前修复错误。<br>我们前面提到过，子类继承了父类的所有成员，包括实例和静态变量、方法和嵌套类，但不包括构造函数。</p>
<p>虽然构造函数不能被继承，但是 Java 要求所有构造函数都必须从调用其超类的某个构造函数开始。</p>
<p>强制类型转换是一种强大但危险的工具。本质上，强制类型转换就是告诉编译器不要执行其类型检查任务 - 告诉它信任您并按照您希望的方式行事。</p>
<p>VengefulSLList extends SLList意味着 VengefulSLList “是一个” SLList，并且继承了 SLList 的所有成员：</p>
<p>变量、方法嵌套类<br>非构造函数子类构造函数必须先调用超类构造函数。super关键字可用于调用重写的超类方法和构造函数。<br>重写方法的调用遵循两个简单的规则：</p>
<p>编译器很谨慎，只允许我们根据静态类型做事。<br>对于重写方法（而非重载方法），实际调用的方法取决于调用表达式的动态类型<br>可以使用强制类型转换来推翻编译器的类型检查。</p>
<p>我们已经看到接口可以做很多很酷的事情！它们允许您利用接口继承和实现继承。作为复习，以下是接口的特性：</p>
<p>所有方法都必须是公开的。<br>所有变量都必须是公共静态最终变量。<br>无法实例化<br>所有方法默认都是抽象的，除非特别指定default<br>每个类可以实现多个接口</p>
<p>现在我们来介绍一个介于接口和具体类之间的新类：抽象类。抽象类的特点如下：</p>
<p>方法可以是公共的或私有的<br>可以有任何类型的变量<br>无法实例化<br>方法默认为具体方法，除非特别指定abstract<br>每个类只能实现一个<br>基本上，抽象类可以完成接口可以做的所有事情，甚至更多。</p>
<p>包名给所有事物赋予了规范的名称。规范意味着事物的独特表示。</p>
<p>这很烦人。我们可以通过导入包来解决这个问题。</p>
<p>除非这些变量被声明final（这不是可变性的唯一条件——还有许多其他方法可以定义数据类型以使其可变）。这是因为外部方法可以更改非私有变量的值，从而导致可观察到的变化。</p>
<p>关键字final是变量的关键字，可防止变量在首次赋值后被更改。</p>
<p>此类是不可变的。实例化 后Date，无法更改其任何属性的值。</p>
<p>不可变数据类型的优点：</p>
<p>由于属性永远不能改变，因此可以防止出现错误并使调试更容易<br>你可以依赖对象具有特定的行为&#x2F;特征</p>
<h1 id="不相交集"><a href="#不相交集" class="headerlink" title="不相交集"></a>不相交集</h1><h2 id="9-1"><a href="#9-1" class="headerlink" title="9.1"></a>9.1</h2><p>如果两个集合没有共同元素，则它们被称为不相交集合。不相交集合（或并查集）数据结构跟踪划分为多个不相交集合的固定数量的元素。该数据结构有两种操作：</p>
<p>connect(x, y)：连接x和y。也称为union<br>isConnected(x, y)：如果x和y是连通的（即属于同一集合），则返回 true。</p>
<p>除了学习如何实现一个迷人的数据结构之外，本章还将提供一个机会来了解数据结构的实现如何演变。我们将讨论不相交集设计的四次迭代，直到满意为止：快速查找 → 快速合并 → 加权快速合并 (WQU) → 带路径压缩的 WQU。我们将看到设计决策如何极大地影响渐近运行时间和代码复杂性</p>
<h2 id="9-2"><a href="#9-2" class="headerlink" title="9.2"></a>9.2</h2><p>快速查找</p>
<p>让我们考虑另一种使用单个整数数组的方法。</p>
<p>数组的索引代表我们集合的元素。<br>索引处的值是它所属的集合编号。</p>
<p>connect(x, y)<br>让我们看看 connect 操作是如何工作的。现在，id[2] &#x3D; 4和id[3] &#x3D; 5。调用后connect(2, 3)，所有 id 为 4 和 5 的元素都应具有相同的 id。我们现在为它们全部赋值 5：</p>
<p>要检查isConnected(x, y)，我们只需检查id[x] &#x3D;&#x3D; id[y]。请注意，这是一个恒定时间操作！</p>
<p>我们将这种实现称为“快速查找”，因为查找元素是否连接需要恒定的时间。</p>
<h2 id="9-3"><a href="#9-3" class="headerlink" title="9.3"></a>9.3</h2><p>快速合并</p>
<p>假设我们优先考虑connect加快操作速度。我们仍将使用数组表示集合。我们为每个项目分配其父项的索引，而不是 id。如果某个项目没有父项，则它为“根”，我们为其分配一个负值。</p>
<p>对于 QuickUnion ，我们定义了一个辅助函数find(int item)，它返回树的根item所在的位置。例如，对于上面的集合，，，，find(4) &#x3D;&#x3D; 0等等。每个元素都有一个唯一的根。find(1) &#x3D;&#x3D; 0find(5) &#x3D;&#x3D; 3</p>
<p>在最好的情况下，如果x和y都是其树的根，则connect(x, y)只需x指向y，即 Θ(1) 运算！（因此得名 QuickUnion）</p>
<p>connect(x, y)<br>要连接两个项目，我们需要找到每个项目所属的集合（它们各自树的根），并将其中一个设为另一个的子项。</p>
<p>isConnected(x, y)<br>如果两个元素属于同一集合，那么它们将位于同一棵树中。因此，它们将具有相同的根。因此，对于isConnected(x, y)我们只需检查是否find(x) &#x3D;&#x3D; find(y)。</p>
<p>QuickUnion 存在一个潜在的性能问题：树可能会变得非常长。在这种情况下，查找项目的根</p>
<p>从运行时间图表来看，QuickUnion 似乎比 QuickFind 更差！但请注意，O(N) 是上限。当我们的树平衡时，connect和的isConnected表现都相当好。在下一节中，我们将了解如何保证它们表现良好。</p>
<h2 id="9-4"><a href="#9-4" class="headerlink" title="9.4"></a>9.4</h2><p>加权快速联合 (WQU)</p>
<p>改进 Quick Union 依赖于一个关键见解：每当我们调用 时find，我们都必须爬到树的根部。因此，树越短，速度越快！</p>
<p>新规则：每当我们调用时，我们总是将较小树connect的根链接到较大树。</p>
<p>遵循此规则将使您的树木最大高度<br>对数N，其中 N 是我们的不相交集合中的元素数量。<br>我们通过树中的项目数来确定较小&#x2F;较大。因此，在连接两棵树时，我们需要知道它们的大小（或重量）。我们可以通过将 替换-1为来将此信息存储在树的根中。</p>
<h2 id="9-4-1"><a href="#9-4-1" class="headerlink" title="9.4"></a>9.4</h2><p>带路径压缩的加权快速合并</p>
<p>聪明的洞察力在于意识到每当我们调用时，find(x)我们都必须遍历从根到根的路径x。因此，我们可以沿途将我们访问的所有项目连接到它们的根，而无需额外的渐近成本。</p>
<p>将沿途的所有项目连接到根将有助于我们的树在每次调用时变得更短find</p>
<p>回想一下，connect(x, y)和isConnected(x, y)总是调用find(x)和find(y)。因此，在调用connect或isConnected足够多之后，基本上所有元素都将直接指向它们的根。</p>
<p>N: number of elements in Disjoint Set</p>
<p>Implementation	isConnected	connect<br>Quick Find	Θ(N)	Θ(1)<br>Quick Union	O(N)	O(N)<br>Weighted Quick Union (WQU)	O(log N)	O(log N)<br>WQU with Path Compression	O(α(N))*	O(α(N))*</p>
<h1 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h1><h2 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h2><p>抽象数据类型 (ADT) 仅由其操作定义，而不是由其实现定义。例如，在 proj1a 中，我们开发了具有相同方法的 ArrayDeque 和 LinkedListDeque，但这些方法的编写方式却大不相同。在这种情况下，我们说 ArrayDeque 和 LinkedListDeque 是Deque ADT 的实现。</p>
<table>
<thead>
<tr>
<th>ADT</th>
<th>描述</th>
<th>常用操作</th>
<th>操作描述</th>
</tr>
</thead>
<tbody><tr>
<td>堆栈</td>
<td>支持后进先出（LIFO）检索元素的结构</td>
<td>push(int x)</td>
<td>将 x 放在堆栈顶部</td>
</tr>
<tr>
<td></td>
<td></td>
<td>int pop()</td>
<td>获取堆栈顶部的元素</td>
</tr>
<tr>
<td>列表</td>
<td>元素的有序集合</td>
<td>add(int i)</td>
<td>添加元素</td>
</tr>
<tr>
<td></td>
<td></td>
<td>int get(int i)</td>
<td>获取索引 i 处的元素</td>
</tr>
<tr>
<td>集合</td>
<td>无序的唯一元素集（无重复）</td>
<td>add(int i)</td>
<td>添加元素</td>
</tr>
<tr>
<td></td>
<td></td>
<td>boolean contains(int i)</td>
<td>返回布尔值，表示集合是否包含该值</td>
</tr>
<tr>
<td>Maps</td>
<td>键&#x2F;值对的集合</td>
<td>put(K key, V value)</td>
<td>将键值对放入 Map 中</td>
</tr>
<tr>
<td></td>
<td></td>
<td>V get(K key)</td>
<td>获取 key 对应的值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>特性</th>
<th>ADT （抽象数据类型）</th>
<th>接口（Interface）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>定义数据和操作的抽象概念</td>
<td>定义类必须实现的行为规范</td>
</tr>
<tr>
<td><strong>侧重点</strong></td>
<td>关注如何操作数据</td>
<td>关注方法的签名和类的行为</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>用于设计数据结构（如堆栈、队列）</td>
<td>用于定义类的公共行为接口（如 Java 中的 List）</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td>不规定具体实现方式，可以用不同数据结构实现</td>
<td>必须由类具体实现，接口只定义方法签名</td>
</tr>
<tr>
<td><strong>包含数据</strong></td>
<td>包含数据和方法</td>
<td>不包含数据，只定义方法</td>
</tr>
<tr>
<td><strong>语言支持</strong></td>
<td>一种概念，不依赖语言的具体支持</td>
<td>是编程语言中的具体语法结构，常见于 OOP 语言</td>
</tr>
</tbody></table>
<h2 id="10-2"><a href="#10-2" class="headerlink" title="10.2"></a>10.2</h2><p>二叉搜索树</p>
<p>链表很棒，但搜索一个项目需要很长时间，即使列表是排序的！如果项目位于列表末尾怎么办？这将花费线性时间！</p>
<p>对于数组，我们可以使用二分搜索来更快地找到元素。具体来说，<br>对数（n ）时间</p>
<p>树木由以下部分组成：</p>
<p>节点<br>连接这些节点的边。<br>约束：任意两个节点之间只有一条路径。<br>在某些树中，我们选择一个没有父节点的根节点。</p>
<p>树也有叶子，即没有子节点的节点。</p>
<p>二叉树：除了上述要求外，还满足二叉性质约束。即每个节点有 0、1 或 2 个子节点。</p>
<p>二叉搜索树：除了上述所有要求之外，还具有以下属性：对于树中的每个节点 X：</p>
<p>左子树中的每个键都小于 X 的键。<br>右子树中的每个键都大于 X 的键。**记住这个属性！！我们将在本模块和 61B 的整个过程中多次引用它。</p>
<p>二叉搜索树操作</p>
<p>搜索<br>为了搜索某些内容，我们使用二分搜索，这由于上一节中描述的 BST 属性而变得简单！</p>
<p>我们知道 BST 的结构是节点右侧的所有元素都较大，而左侧的所有元素都较小。了解了这一点，我们可以从根节点开始，将其与我们要查找的元素 X 进行比较。如果 X 大于根，则转到根的右子节点。如果 X 较小，则转到根的左子节点。我们递归重复此过程，直到找到该项目或到达叶子节点（在这种情况下，树不包含该项目）。</p>
<p>如果我们的树相对“茂密”，则查找操作将运行<br>对数（n ）时间因为树的高度是 logn，所以这非常快！</p>
<p>插入</p>
<p>我们总是在叶节点插入！</p>
<p>首先，我们在树中搜索节点。如果找到它，则我们什么也不做。如果找不到它，我们将已经位于叶节点。此时，我们可以将新元素添加到叶的左侧或右侧，从而保留 BST 属性</p>
<p>删除</p>
<p>BST 作为集合和映射</p>
<p>我们可以使用 BST 来实现SetADT！但它甚至更好，因为在 ArraySet 中，我们有最坏的情况​​因为我们需要搜索整个集合，所以运行时间会缩短contains。但是，如果我们使用 BST，我们可以将运行时间缩短到<br>对数（n ）因为 BST 属性使我们能够使用二分搜索！</p>
<p>我们还可以通过让每个 BST 节点保存成对而不是奇异值，将二叉树变成映射(key,value)。我们将比较每个元素的键，以确定将其放置在树中的哪个位置。</p>
<h1 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h1><h2 id="11-1"><a href="#11-1" class="headerlink" title="11.1"></a>11.1</h2><p>二叉树高度</p>
<p>最坏情况树和最佳情况树之间的运行时间差异非常大。<br>最坏是n，最好是logn，</p>
<p>简要介绍一下 BigO 和最坏情况<br>BigO不等同于最坏情况！请记住，BigO 是一个上限。只要函数在该范围内，它就被视为在该函数的 BigO 内。最坏情况比 BigO 更严格。</p>
<p>BST 性能</p>
<p>BST 性能的一些术语：</p>
<p>深度：节点和根之间的链接数。<br>高度：树的最低深度。<br>平均深度：树中总深度的平均值</p>
<p>树的高度决定了最坏情况的运行时间，因为在最坏的情况下我们正在寻找的节点位于树的底部。</p>
<p>平均深度决定平均运行时间。</p>
<p>我们并不总是能够以随机顺序插入 BST。如果我们的数据是实时到达的怎么办？那么，我们将被迫按照数据到达我们的顺序进行插入。</p>
<p>下一章我们将学习一棵始终保持平衡的树！</p>
<h2 id="11-2"><a href="#11-2" class="headerlink" title="11.2"></a>11.2</h2><p>B 树</p>
<p>没看懂</p>
<p>旋转树<br>B 树虽然非常平衡，但实现起来却非常困难。我们需要跟踪不同的节点，而且拆分过程非常复杂<br>下面是节点 G 左旋转时发生的情况的图形描述。</p>
<p>G 的右子节点 P 与 G 合并，并带走它的子节点。然后 P 将其左子节点传递给 G，G 向左移动成为 P 的左子节点。您可以看到树的结构以及层数都发生了变化。我们还可以在非根节点上进行旋转。我们只需暂时断开节点与父节点的连接，旋转该节点处的子树，然后重新连接新的根节点。</p>
<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="12-1"><a href="#12-1" class="headerlink" title="12.1"></a>12.1</h2><p><strong>到目前为止我们看到的问题</strong></p>
<p>到目前为止，我们已经了解了一些用于高效搜索数据结构中项目存在性的数据结构。我们了解了二叉搜索树，然后使用 2-3 树使它们保持平衡。<br>然而，这些结构也有一些限制<br>它们要求项目具有可比性。你如何决定新项目在 BST 中的位置？你必须回答“你比根小还是大”这个问题？对于某些对象，这个问题可能毫无意义。<br>它们给出的复杂度为对数N ）。这样好吗？当然好。但也许我们可以做得更好。</p>
<p>第一次尝试：<strong>DataIndexedIntegerSet</strong></p>
<p>我们创建一个类型boolean和大小为 20 亿的 ArrayList。默认让所有内容都为 false。</p>
<p>该add(int x)方法只是将xArrayList 中的位置设置为 true。这需要Θ ( 1 )时间。<br>该contains(int x)方法只是返回xArrayList 中的位置是true还是false。这还需要Θ ( 1 )时间！</p>
<p><strong>潜在问题</strong></p>
<p>极其浪费。如果我们假设 aboolean占用 1 个字节来存储，则上述2GB每个 需要的空间new DataIndexedIntegerSet()。此外，用户可能只会插入少量项目……<br>如果有人想插入，我们该怎么办String？<br>接下来我们来看看这个。当然，我们可能想插入其他内容，比如Dogs。这很快就会实现！</p>
<h2 id="12-2"><a href="#12-2" class="headerlink" title="12.2"></a>12.2</h2><p><strong>解决单词插入问题</strong></p>
<p>如果有人想在我们的数据结构中添加一只“猫”，我们会‘找出’“猫”的数字是 1，然后设置present[1]为true。如果有人想问我们“猫”是否在我们的数据结构中，我们会‘找出’“猫”是 1，并检查是否present[1]为真。我们需要制定一个通用策略，这样给定一个字符串，我们就可以找出它的数字表示。</p>
<p><strong>避免碰撞</strong></p>
<p>将小写字母和1到26相对应，比如cat &#x3D; 3 1  20<br>将其转换为10进制，2074</p>
<p>这种表示法为每个包含小写字母的英文单词提供了一个唯一的整数，就像使用十进制为每个数字提供了一个唯一的表示一样。我们保证不会发生冲突。</p>
<p><strong>我们在哪里</strong></p>
<p>回想一下，我们一开始想要对数N ）。现在我们已经对整数和单个英文单词完成了此操作。</p>
<p>(b) 允许不可比较的项。我们还没有触及这一点，尽管我们正在接近这一点。到目前为止，我们只学习了如何添加整数和英文单词，这两者都是可比较的，但是，我们是否曾经使用过它们是可比较的事实？即，我们是否曾经尝试过比较它们（就像我们在 BST 中所做的那样）？没有。所以我们正在接近这一点，但我们实际上还没有插入任何不可比较的东西。</p>
<p>(c) 我们有插入整数和英文单词的数据结构。让我们快速了解如何插入任意String对象，包括空格等。甚至可以插入其他语言和表情符号！</p>
<p>（d）进一步回想一下，我们的方法仍然非常浪费内存。我们还没有解决这个问题！</p>
<h2 id="12-3"><a href="#12-3" class="headerlink" title="12.3"></a>12.3</h2><p>在我们创建整数的时候会出现整数溢出。</p>
<p>所以我们要处理碰撞</p>
<p>一个微妙的观点<br>请注意，我们的问题本质上不是溢出存在。我们想要的只是找到一种将 a 转换String为数字的方法。即使存在溢出，我们也能设法将 a 转换为数字。</p>
<p><strong>哈希码</strong><br>在计算机科学中，将一个对象转换为某个整数称为“计算该对象的哈希码”。例如，“melt banana”的哈希码是 839099497。</p>
<p>我们研究了如何计算字符串的哈希码。对于其他对象，我们执行以下两项操作之一：</p>
<p>Java 中的每个对象都有一个默认.hashcode()方法，我们可以使用它。Java 通过找出Object内存中的位置（计算机内存的每个部分都有一个地址！）来计算此方法，并使用该内存地址执行类似于我们对Strings 执行的操作。此方法为每个 Java 对象提供唯一的哈希码。<br>有时，我们会编写自己的hashcode方法。例如，给定一个，我们可以使用其和的Dog组合来生成一个。nameagebreedhashcode</p>
<p><strong>HashCodes 的属性</strong><br>哈希码具有三个必要属性，这意味着哈希码必须具有这些属性才能有效：</p>
<p>它必须是整数<br>如果我们.hashCode()对一个对象运行两次，它应该返回相同的数字<br>考虑的两个对象.equal()必须具有相同的哈希码。<br>然而，并非所有哈希码都是平等的。如果你希望你的哈希码被认为是一个好的哈希码，它应该：</p>
<p>均匀分布物品<br>请注意，此时，我们知道如何向我们的数据结构中添加任意对象，而不仅仅是字符串。</p>
<p><strong>未决问题</strong><br>空间：我们还没有想出如何利用更少的空间。<br>处理碰撞：我们已经确定需要处理碰撞，但实际上还没有处理它们。<br>其余一切都已解决！</p>
<h2 id="12-4"><a href="#12-4" class="headerlink" title="12.4"></a>12.4</h2><p><strong>处理碰撞</strong></p>
<p>我们可以改变我们的数组让他可以包含列表，这样重复的列表就可以放在列表当中了。</p>
<p><strong>具体工作流程</strong><br>add物品<br>获取项目的哈希码（即索引）。<br>如果索引没有项目，则创建新列表并将项目放置在那里。<br>如果索引已经有列表，则检查列表以查看项目是否已在其中。如果没有，则将项目添加到列表中。<br>contains物品<br>获取项目的哈希码（即索引）。<br>如果索引为空，则返回false。<br>否则，检查列表中该索引处的所有项目，如果该项目存在，则返回true。</p>
<p><strong>解决空间</strong></p>
<p>一个想法：取模。我们只需创建一个大小为 100 的 ArrayList。我们不要改变hashcode函数的行为（让它返回一个非常大的整数）。但在我们得到之后hashcode，我们将取其模 100 以获得<br>0 … 9 9我们想要的范围。如果发生碰撞？没关系，我们知道如何处理！</p>
<p>请注意，数组中的 LinkedLists 现在会更长，因为我们将把分布在 40 亿个索引中的所有项目压缩为 100 个索引。</p>
<h2 id="12-5"><a href="#12-5" class="headerlink" title="12.5"></a>12.5</h2><p><strong>HashTable</strong></p>
<p>输入由哈希函数 ( ) 转换hashcode为整数。然后，使用模数运算符将它们转换为有效索引。然后，将它们添加到该索引处（使用 LinkedLists 处理冲突）。<br>contains以类似的方式工作，通过找出有效索引，并在相应的 LinkedList 中查找该项目。</p>
<p><strong>处理运行时</strong><br>剩下要解决的唯一问题是运行时问题。如果我们有 100 个项目，并且我们的 ArrayList 大小为 5，那么</p>
<p>在最佳情况下，所有项目都会均匀地发送到不同的索引。也就是说，我们有 5 个 linkedList，每个包含 20 个项目。<br>在最坏的情况下，所有项目都会被发送到同一个索引！也就是说，我们只有 1 个 LinkedList，但它包含全部 100 个项目。<br>有两种方法可以尝试修复此问题：</p>
<p>动态增加我们的哈希表。<br>改进我们的哈希码</p>
<p><strong>负载率</strong></p>
<p>N&#x2F;M。m是索引个数，</p>
<p>策略？每隔一段时间，只需加倍。我们这样做的方法如下：</p>
<p>创建一个具有 2M 个存储桶的新 HashTable。<br>遍历旧 HashTable 中的所有项目，然后逐个将它们添加到这个新的 HashTable 中。<br>我们需要再次逐个添加元素，因为由于数组的大小发生了变化，模数也会发生变化，因此该项目可能属于新哈希表中与旧哈希表中不同的存储桶。</p>
<p>我们通过设置负载因子阈值来实现这一点。一旦负载因子大于此阈值，我们就会调整大小</p>
<p>另请注意，调整大小需要<br>Θ （N ）时间。为什么？因为我们需要添加<br>否<br>否将项目添加到哈希表中，并且每次添加都需要<br>Θ ( 1 )时间。</p>
<p>一个小问题：在进行调整大小时，我们实际上并不需要检查项目是否已经存在于 LinkedList 中（因为我们知道没有重复项），因此我们可以直接添加每个项目<br>Θ ( 1 )通过将项目添加到链接列表的前面，可以节省时间。（回想一下，通常我们必须搜索 LinkedList 以确保该项目不在那里……但我们可以在调整大小时跳过该步骤。）</p>
<p>当然，我们需要重新审视我们假设项目均匀分布的假设。如果项目分布不均匀，我们的运行时间将是<br>Θ （N ）因为可能存在一个大小为n</p>
<p><strong>假设物品均匀分布？</strong><br>如果我们有好的哈希码（即，哈希码为不同的项目提供相当随机的值），则项目将均匀分布。一般来说，做到这一点… 嗯… 很难。</p>
<p>一些一般的经验法则：</p>
<p>使用与我们之前开发的类似的“基础”策略。<br>使用小素数作为“基数”。<br>基数 126 实际上并不是很好，因为使用基数 126 意味着以相同的最后 32 个字符结尾的任何字符串都具有相同的哈希码。<br>这是由于溢出造成的。<br>使用素数有助于避免溢出问题（即由于溢出而导致的冲突）。<br>为什么是小素数？因为它更容易计算。</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p><strong>优先级队列接口</strong></p>
<p>优先级队列是一种抽象数据类型，可优化处理最小或最大元素。<br>使用这种专门的数据结构可以带来空间&#x2F;内存方面的好处。<br>我们当前所知的 ADT 实现并不能为我们提供 PQ 操作的有效运行时间。<br>在其他结构中，二叉搜索树是最有效的</p>
<p>对于我们的 PQ 操作来说，已知的运行时间最短的数据结构是二叉搜索树。通过修改其结构和约束，我们可以进一步提高这些操作的运行时间和效率。我们将二叉最小堆定义为完整的并遵循最小堆属性：</p>
<p>最小堆：每个节点都小于或等于其两个子节点<br>完整：仅底层缺少项目（如果有），所有节点都尽可能位于左边。</p>
<p>我们关心的 PriorityQueue ADT 的三个方法是add、getSmallest和removeSmallest。我们将首先从概念上描述如何在给定堆模式的情况下实现这些方法。</p>
<p>add：暂时添加到堆尾。沿层次结构向上移动到适当位置。<br>如果子节点 &lt; 父节点，则游泳涉及交换节点<br>getSmallest：返回堆的根（这保证了我们的最小堆属性是最小的<br>removeSmallest：将堆中的最后一个项交换到根。将层次结构下沉到适当的位置。<br>如果父节点 &gt; 子节点，则下沉涉及交换节点。与最小的子节点交换以保留最小堆属性</p>
<p><strong>方法 1a、1b 和 1c</strong><br>让我们考虑一下最直观且以前使用过的树表示法。我们将在节点和其子节点之间创建映射。有几种方法可以做到这一点，我们现在将进行探索。</p>
<p>在方法Tree1A中，我们考虑创建指向子节点的指针，并将值存储在节点对象内部。这些是硬连线链接，</p>
<p>或者，在Tree1B中，我们探索使用数组来表示子节点和节点之间的映射。这将为我们提供可变宽度的节点，但遍历也会很麻烦，性能也会更差</p>
<p>我们可以使用Tree1C的方法。这与我们见过的常用方法略有不同。我们说节点不仅可以表示节点的子节点，还可以维护对其兄弟节点的引用。</p>
<p>我们和本书将使用的实际实现与上一章末尾讨论的表示非常相似。唯一的区别是，我们将在数组开头留出一个空位以简化计算。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>王思懿</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span><strong>白鸟青山鸣，迷途何复归</strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/09/16/cs61b/Style%20Guide/">Style Guide</a>
            
            
            <a class="next" rel="next" href="/2024/05/27/Diary/Diary_022/">电子日记022周日</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 王思懿 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>